<?php
/**
 * Copyright (c) 2017.
 * @author Nikola Tesic (nikolatesic@gmail.com)
 */

namespace andrej2013\yiiboilerplate\templates\test;

use Yii;
use yii\db\ActiveQuery;
use yii\db\ActiveRecord;
use yii\db\BaseActiveRecord;
use yii\db\ColumnSchema;
use yii\gii\CodeFile;
use yii\helpers\FileHelper;
use yii\helpers\Inflector;
use yii\db\Schema;
use schmunk42\giiant\generators\model\Generator as BaseGenerator;

/**
 * This generator will generate one or multiple ActiveRecord classes for the specified database table.
 *
 * @author Tobias Munk <schmunk@usrbin.de>
 * @since  0.0.1
 */
class Generator extends \yii\gii\Generator
{
    public $modelClass = 'app\\models\\';
    public $models = [];
    public $testPath = '@root/tests/codeception';

    public static $prevId;

    /**
     * @var int How much models will be created for fixture data
     */
    protected $generatedFixtures;

    /**
     * @inheritdoc
     */
    public function init()
    {
        parent::init(); // TODO: Change the autogenerated stub
        $this->generatedFixtures = getenv('TEST_GENERATED_FIXTURES') ? getenv('TEST_GENERATED_FIXTURES') : 4;
    }

    /**
     * @return string
     */
    public function getName()
    {
        return 'Giiant Test';
    }

    /**
     * @return string
     */
    public function getDescription()
    {
        return 'This generator generates Codeception test';
    }

    /**
     * @return array
     */
    public function rules()
    {
        return array_merge(parent::rules(), [
            [['models'], 'safe'],
            [['modelClass'], 'filter', 'filter' => 'trim'],
            [['modelClass', 'testPath'], 'required'],
//            [['modelClass'], 'match', 'pattern' => '/^[\w\\\\]*$/',
//                'message' => 'Only word characters and backslashes are allowed.'],
//            [['modelClass'], 'validateClass', 'params' => ['extends' => BaseActiveRecord::className()]],
//            [['modelClass'], 'validateModelClass'],
        ]);
    }

    /**
     * @return array
     */
    public function attributeLabels()
    {
        return array_merge(parent::attributeLabels(), [
            'modelClass' => 'Model Class',
            'models' => 'Model Class',
            'testPath' => 'Test Path',
        ]);
    }

    /**
     * @return array
     */
    public function hints()
    {
        return array_merge(parent::hints(), [
            'modelClass' => 'This is the ActiveRecord class associated with the table that CRUD will be built upon.
                You should provide a fully qualified class name, e.g., <code>app\models\Post</code>.',
            'testPath' => 'Specify the directory for storing the test scripts for the model. You may use path alias here, e.g.,
                <code>/var/www/basic/tests</code>, <code>@root/tests</code>. If not set, it will default
                to <code>@root/tests/codeception</code>',
        ]);
    }

    /**
     * @return string the test path
     */
    public function getTestPath()
    {
        //@TODO make sure there is @root alias registered
        if (empty($this->testPath)) {
            return Yii::getAlias('@root/test/codeception');
        } else {
            return Yii::getAlias($this->testPath);
        }
    }

    /**
     * Checks if model class is valid
     */
    public function validateModelClass()
    {
        /* @var $class ActiveRecord */
        $class = $this->modelClass;
        $pk = $class::primaryKey();
        if (empty($pk)) {
            $this->addError('modelClass', "The table associated with $class must have primary key(s).");
        }
    }

    /**
     * @inheritdoc
     */
    public function requiredTemplates()
    {
        return [
            'api/api.php',
            'functional/functional.php',
            'unit/models/unit.php',
        ];
    }

    /**
     * @inheritdoc
     */
    public function stickyAttributes()
    {
        return array_merge(parent::stickyAttributes(), ['testPath']);
    }

    /**
     * @inheritdoc
     */
    public function generate()
    {
        $files = [];
        foreach ($this->models as $model) {
            $this->modelClass = 'app\\models\\' . $model;
            $apiFile = $this->getTestPath() . '/api/' . $this->getModelShortName() . 'Cept.php';
            $functionalFile = $this->getTestPath() . '/functional/' . $this->getModelShortName() . 'Cept.php';
            $unitFile = $this->getTestPath() . '/unit/models/' . $this->getModelShortName() . 'Test.php';
            $fixtureData = $this->getTestPath() . '/fixtures/data/' . Inflector::camel2id($this->getModelShortName(), '_') . '.php';
            $fixture = $this->getTestPath() . '/fixtures/' . $this->getModelShortName() . 'Fixtures.php';
            $acceptance = $this->getTestPath() . '/acceptance/app/' . $this->getModelShortName() . 'Cept.php';
            $files[] = new CodeFile($apiFile, $this->render("api/api.php"));
            $files[] = new CodeFile($functionalFile, $this->render("functional/functional.php"));
            $files[] = new CodeFile($unitFile, $this->render("unit/models/unit.php"));
            $files[] = new CodeFile($fixtureData, $this->render("fixtures/data/data.php"));
            $files[] = new CodeFile($fixture, $this->render("fixtures/fixtures.php"));
            $files[] = new CodeFile($acceptance, $this->render("acceptance/acceptance.php"));
        }
        return $files;
    }

    /**
     * @return string Return model short name without namespace
     */
    public function getModelShortName()
    {
        $reflection = new \ReflectionClass($this->modelClass);
        return $reflection->getShortName();
    }

    /**
     * Returns table schema for current model class or false if it is not an active record
     * @return boolean|\yii\db\TableSchema
     */
    public function getTableSchema()
    {
        /* @var $class ActiveRecord */
        $class = $this->modelClass;
        if (is_subclass_of($class, 'yii\db\ActiveRecord')) {
            return $class::getTableSchema();
        } else {
            return false;
        }
    }

    /**
     * Get proper random value for given attribute for text fixtures data
     * @param      $attribute
     * @param null $id
     * @return bool|int|null|string
     */
    public function getProperAttributeValue($attribute, $id = null)
    {
        if ($id === null) {
            // If not set $id generate random number that is not in range of 1-4 that is used for fixtures
            $id = random_int($this->generatedFixtures + 1, $this->generatedFixtures + 20);
        }
        $column = $this->getTableSchema()->getColumn($attribute);
        if ($column->dbType == 'tinyint') {
            $value = random_int(0, 1);
        } elseif ($this->isEnum($column)) {
            $enumValues = $this->getEnumValues($column);
            $rand = array_rand($enumValues);
            $value = $enumValues[$rand];
        } else {
            switch ($column->type) {
                case 'string':
                case 'char':
                    $value = $this->generateText($column, $attribute, $id);
                    break;
                case 'text':
                    $value = "$attribute $id";
                    break;
                case 'datetime':
                    $value = date('Y-m-d H:i:s');
                    break;
                case 'date':
                    $value = date('Y-m-d');
                    break;
                case 'time':
                    $value = date('H:i:s');
                    break;
                case 'timestamp':
                case 'bigint':
                case 'float':
                case 'decimal':
                case 'money':
                case 'smallint':
                case 'integer':
                    // If attribute have relation to other model and not calling from fixtures data set foreign key to
                    // 1-4 that is always present
                    if ($this->hasRelation($attribute) && $id > $this->generatedFixtures) {
                        $rand = random_int(1, $this->generatedFixtures);
                        if ($rand == self::$prevId) {
                            if ($rand == 1) {
                                $rand = $rand + 1;
                            } else {
                                $rand = $rand - 1;
                            }
                        }
                        self::$prevId = $rand;
                        $value = $rand;
                    } else {
                        $value = $id;
                    }
                    break;
                case 'boolean':
                case 'tinyint':
                    //PHP7 function
                    $value = random_int(0, 1);
                    break;
                default:
                    $value = $id;
            }
        }
        return $value;
    }

    /**
     * Columns not to change in generation
     * @return array
     */
    public function avoidColumns()
    {
        return ['created_at', 'created_by', 'updated_at', 'updated_by', 'deleted_at', 'deleted_by'];
    }

    /**
     * Get proper controller route for created model
     * @return string
     */
    public function getControllerRoute()
    {
        $model = str_replace(['\\models', '\\app', 'app\\', 'models\\'], '', $this->modelClass);
        $parts = explode('\\', $model);
        $route = '';
        foreach ($parts as $part) {
            $route .= Inflector::camel2id($part) . '/';
        }
        return rtrim($route, '/');
    }

    /**
     * Get models required fields
     * @return array
     */
    public function getRequiredAttributes()
    {
        /* @var $class ActiveRecord */
        $class = $this->modelClass;
        $class = new $class;
        $required = [];
        foreach ($class->attributes as $attribute => $temp) {
            if ($class->isAttributeRequired($attribute)) {
                $required[] = $attribute;
            }
        }
        return $required;
    }

    /**
     * Build array list of required fields with their proper values
     * in format ['attribute1' => 'value1', 'attribute2' => 'value2']
     * @return string
     */
    public function getRequiredQuery()
    {
        $query = '';
        foreach ($this->getRequiredAttributes() as $attribute) {
            $query .= "'$attribute' => '" . $this->getProperAttributeValue($attribute) . "', ";
        }
        return rtrim($query, ', ');
    }

    /**
     * @return \string[]
     */
    public function getPrimaryKeyNames()
    {
        /**
         * @var $model ActiveRecord
         */
        $model = new $this->modelClass;
        return $model->primaryKey();
    }

    /**
     * Build query string for finding model by primary keys
     * @return string
     */
    public function buildPkQueryCondition()
    {
        $condition = '';
        foreach ($this->getPrimaryKeyNames() as $pk) {
            $condition .= "'$pk' => \$model->$pk, ";
        }
        return rtrim($condition, ', ');
    }

    /**
     * Build query string for finding model by primary keys with values of existing fixtures
     * @return string
     */
    public function buildPkQueryConditionExisting()
    {
        $condition = '';
        $randInt = random_int(1, $this->generatedFixtures);
        foreach ($this->getPrimaryKeyNames() as $pk) {
            $condition .= "'$pk' => " . $randInt . ', ';
        }
        return rtrim($condition, ', ');
    }

    /**
     * @param $attribute
     * @return bool true if attribute has relation to some other model
     */
    public function hasRelation($attribute)
    {
        if (strpos($attribute, '_id') === false) {
            return false;
        }
        return true;
        $attribute = Inflector::camelize(str_replace('_id', '', $attribute));
        if (in_array($attribute, $this->getRelationModels())) {
            return true;
        }
        return false;
    }

    /**
     * @return array
     */
    public function getRelationModels()
    {
        /**
         * @var $model ActiveRecord
         */
        $model = new $this->modelClass();
        $reflection = new \ReflectionClass($model);
        $relationModels = [];
        foreach ($reflection->getMethods() as $method) {
            // Look only for methods starting with 'get'
            if (substr($method->name, 0, 3) !== 'get') {
                continue;
            }
            $skipMethods = [
                'getRelation',
                'getBehavior',
                'getFirstError',
                'getOperator',
                'getAttributeHint',
                'getAttribute',
                'getAttributeLabel',
                'getOldAttribute',
                'getFileUrl',
                'getFileType',
                'getUploadPath',
                'getHistory',
            ];
            if (in_array($method->name, $skipMethods)) {
                continue;
            }

            // Don't use static methods
            $reflection = new \ReflectionMethod($model, $method->name);
            if ($reflection->isStatic()) {
                continue;
            }

            /**
             * @var $relation ActiveQuery
             */
            $relation = @call_user_func([$model, $method->name]);
            if ($relation instanceof ActiveQuery) {
                $relationReflection = new \ReflectionClass(new $relation->modelClass());
                if (!in_array($relationReflection->getShortName(), $relationModels)) {
                    $relationModels[] = $relationReflection->getShortName();
                }
            }
        }
        return $relationModels;
    }

    /**
     * @param string $model
     * @return string
     */
    public function getShortName($model)
    {
        $reflection = new \ReflectionClass(new $model);
        return $reflection->getShortName();
    }

    /**
     * Getter
     * @return mixed
     */
    public function getGeneratedFixtures()
    {
        return $this->generatedFixtures;
    }

    /**
     * @return array
     */
    public static function getModels()
    {
        $files = FileHelper::findFiles(Yii::getAlias('@app/models'), ['recursive' => false]);
        $out = [];
        foreach ($files as $file) {
            $out[pathinfo($file, PATHINFO_FILENAME)] = pathinfo($file, PATHINFO_FILENAME);
        }
        unset($out['User']);
        unset($out['UserTwData']);
        unset($out['TwActiveRecord']);
        return array_filter($out);
    }

    /**
     * @param $column
     * @param $attribute
     * @param $id
     * @return string
     */
    protected function generateText($column, $attribute, $id)
    {
        $size = $column->size;
        $output = "$attribute $id";
        if (strlen($output) > $size) {
            $idSize = strlen($id);
            $output = substr($attribute, 0, ($size - $idSize - 1)) . " $id";
            if (strlen($output) > $size) {
                $output = substr($output, 0, $size);
            }
        }
        return $output;
    }

    /**
     * @param $column
     * @return bool
     */
    protected function isEnum($column)
    {
        return substr(strtoupper($column->dbType), 0, 4) == 'ENUM';
    }

    /**
     * @param $column
     * @return array
     */
    public function getEnumValues($column)
    {
        $enum = [];

        $enum_values = explode(',', substr($column->dbType, 4, strlen($column->dbType) - 1));

        foreach ($enum_values as $value) {
            $value = trim($value, "()'");
            $enum[] = $value;
        }
        return $enum;
    }

    /**
     * @return bool
     */
    public function anyRequiredColumn()
    {
        $columns = $this->getTableSchema()->columns;
        foreach ($columns as $column) {
            if (!$column->allowNull && $column->defaultValue == null && !$column->autoIncrement) {
                return true;
            }
        }
        return false;
    }
}
